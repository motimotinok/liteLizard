# LiteLizard 要件ヒアリングメモ

最終更新: 2026-02-12（v0.5）

## 0. 目的（現時点）
- エッセイ執筆時に「事実/エピソード」と「意味/二面性」を同時に可視化する。
- 執筆者が主観に飲まれすぎず、読者視点を疑似体験できる 1 画面エディタを作る。

## 1. 受領済みアイデア（要約）
- 2カラム同期UI（左: 執筆、右: AI解析）
- 段落ごとの3軸解析
  - 読者感情シミュレート
  - 浮かび上がるテーマ
  - 深層の意味
- ペルソナ切替
  - 優しい親友
  - 冷徹な編集者
  - 一般読者
- 技術候補
  - Next.js / React
  - サーバーレス + LLM API
- 開発優先
  - Step1: 解析ボタンで右カラム出力
  - Step2: 段落同期
  - Step3: プロンプト磨き込み

## 2. まず確定したい要件（質問）
以下は MVP を最短で形にするための質問です。回答後、このファイルを更新して仕様確定します。

### A. 価値・利用シナリオ
1. このプロダクトで最初に解決したい「1つの痛み」はどれですか？
   - a) 書いても意味づけが弱い
   - b) 読者にどう見えるか不安で止まる
   - c) 構成が散らかる
2. 1回の執筆セッションは、平均何文字・何分くらいを想定しますか？
3. 主な利用端末はどれですか？
   - a) PCのみ
   - b) PC中心 + スマホ閲覧
   - c) スマホ中心

### B. 解析仕様（中核）
4. 解析の粒度は MVP でどちらを優先しますか？
   - a) 全文一括解析（実装が速い）
   - b) 段落別解析（価値が高い）
5. 段落は「空行区切り」で確定してよいですか？
6. 3軸の出力は固定3項目でよいですか？
   - 感情 / テーマ / 深層の意味
7. 出力トーンは、まずは次の3モード固定でよいですか？
   - 優しい親友 / 冷徹な編集者 / 一般読者

### C. UX・操作
8. 解析トリガーは MVP でどれにしますか？
   - a) 解析実行ボタンのみ
   - b) ボタン + 自動再解析（例: 10秒無操作）
9. 解析結果は編集可能にしますか？
   - a) 読み取り専用
   - b) ユーザーがメモ追記可能
10. 保存形式は何を必須にしますか？
   - a) .md のみ
   - b) .md + .txt
   - c) 将来 Notion/公開連携も見据える

### D. 品質・コスト
11. APIコスト上限の目安はありますか？（例: 月1,000円 / 3,000円）
12. 速度目標はありますか？（例: 2,000字で5秒以内）
13. 失敗時の挙動で必須はどれですか？
   - a) リトライボタン
   - b) 部分成功（解析できた段落だけ表示）
   - c) エラー理由表示

### E. 実装・運用
14. LLM は MVP でどちらを優先しますか？
   - a) OpenAI
   - b) Claude
   - c) 切り替え可能設計
15. ログイン機能は MVP に含めますか？
   - a) なし（ローカル保存中心）
   - b) あり（ユーザー管理）
16. 公開範囲はどこまでを想定しますか？
   - a) 完全個人利用
   - b) 限定公開（友人テスト）
   - c) 一般公開

## 3. 決定ログ（2026-02-12 反映）
- Q1: 最初の痛みは `b`（読者にどう見えるか不安で止まる）
- Q2: 解析粒度は `b`（段落別解析）
- Q3: 段落区切りは `空行区切り` で確定
- Q4: 解析トリガーは `a`（解析実行ボタンのみ）
- Q5: MVP 保存形式は `.md`
- Q6: 公開範囲は `c`（一般公開）
- 追加要件: VSCodeのようにローカルファイルを開いて編集できる「ローカルにインストールするエディタアプリ」にしたい

## 4. MVP仕様（v0.1 草案）
- 目的: 執筆が止まる原因である「読者視点の不安」を、段落ごとのAI反応表示で低減する
- UI: 1画面2カラム（左: Markdown執筆、右: 対応段落の解析）
- 解析単位: 空行区切りの段落ごと
- 解析実行: 明示的な「解析実行」ボタン
- 出力: 段落ごとに `感情 / テーマ / 深層の意味`
- 保存: `.md` ファイルとして保存
- 配布方針: 一般公開を想定した配布可能なローカルアプリ

## 5. 未解決リスク
- もともとの「Vercelサーバーレス前提」と「ローカルインストール型アプリ」の技術方針が未統一
- ローカルファイルアクセス権限の設計（読み書き範囲、誤保存防止）が未確定
- APIキー管理方式（ローカル保持か、バックエンド中継か）が未確定
- 一般公開時の配布形態（macOS/Windows）と署名運用が未確定

## 6. 次に確定したい質問（ローカルアプリ前提）
1. デスクトップ実装基盤はどちらを優先しますか？
   - a) Electron（実績重視）
   - b) Tauri（軽量重視）
2. 対応OSの優先順位は？
   - a) macOS先行
   - b) macOS + Windows同時
3. AI呼び出し方式はどちらにしますか？
   - a) クライアントから直接API（実装速い）
   - b) 自前の中継API経由（鍵漏えい耐性）
4. ローカルファイル操作の範囲は？
   - a) 単一ファイルのみ（開く/保存）
   - b) フォルダ単位で複数ファイル管理
5. VSCodeライク要件の優先機能はどれですか？（上位2つ）
   - a) ファイルツリー
   - b) タブ編集
   - c) 検索/置換
   - d) 自動保存
   - e) ショートカット
6. 解析結果の保存先はどうしますか？
   - a) 元.mdにコメントとして埋め込む
   - b) 別ファイル（例: `xxx.analysis.json`）に保持
   - c) セッション中のみ表示（保存しない）

## 7. 追加決定ログ（2026-02-12 追記）
- Q1: デスクトップ基盤は `a`（Electron）
- Q2: 対応OSは `a`（macOS先行）
- Q3: AI呼び出し方式は `b`（自前の中継API経由）
- Q4: ローカルファイル操作は `b`（フォルダ単位で複数ファイル管理）※一旦
- Q5: VSCodeライク優先機能は `a`（ファイルツリー）、`d`（自動保存）
- Q6: 解析結果保存先は「段落の並び替えに対応した辞書形式（`light`/`lizard`）を優先」
- Q7: 解析UIは段落のドラッグ&ドロップ並び替えを必須化
- Q8: 自動保存は `3秒デバウンス`

## 8. Q3の説明（AI呼び出し方式）
### a) クライアントから直接API
- 意味: Electronアプリが OpenAI などのAPIへ直接通信する方式
- 必要: ユーザーのAPIキーをアプリ内で保持
- メリット: 実装が速い、サーバー運用が不要
- デメリット: 一般公開時はキー取り扱いリスクが上がる（漏えい対策が重要）

### b) 自前の中継API経由
- 意味: アプリ -> 自分のサーバー -> LLM API の順で通信する方式
- 必要: 中継サーバーの実装/運用（認証、レート制限、監視）
- メリット: キーをクライアントに配らずに済む、利用制御しやすい
- デメリット: 実装/運用コストが増える

### 現要件での推奨
- あなたの条件（一般公開予定）では、最終的には `b` が安全。
- ただし初期MVPは速度優先で `a` から入り、公開前に `b` へ移行する二段構えが現実的。

## 9. MVP仕様（v0.2 確定）
- アプリ形態: Electron製デスクトップアプリ（macOS先行）
- ファイル操作: フォルダを開く方式（左ペインにファイルツリー）
- 編集対象: Markdown編集 + 構造化ドキュメント管理
- 保存: 自動保存（編集中にローカル保存）
- 解析起動: 「解析実行」ボタンによる手動トリガー
- 解析単位: 空行区切りの段落ごと
- 解析表示: 右カラムに段落対応で `感情 / テーマ / 深層の意味`
- 解析結果の保持: `light`/`lizard` を持つ辞書形式で保持（段落IDベース）
- 編集操作: 段落カードをドラッグ&ドロップで並び替え可能
- AI接続: 自前の中継API経由
- 公開方針: 一般公開を前提

## 10. 技術方針（v0.2）
- フロント: Electron + React（レンダラ）
- ローカルI/O: Electron Main processで安全なファイルAPIを提供
- API通信: Renderer -> Main -> 自前中継API -> LLM
- セキュリティ: APIキーはクライアントに配布しない（中継側で保持）
- 永続化形式: `.litelizard.json` を正本とし、`.md` は入出力/エクスポートに利用
- データ構造: 段落ごとに `id`, `light`, `lizard` を保持し、UI加工と並び替えを容易化

## 11. 最短開発ステップ（実装順）
1. Electron雛形 + 1画面レイアウト（左エディタ/右解析）
2. フォルダオープンとファイルツリー表示、`.md`読込
3. 自動保存（dirty state管理付き）
4. 段落分割ロジック（空行区切り）と右カラム同期表示
5. 「解析実行」ボタンで中継API呼び出し
6. 3軸レスポンスを段落ごとに描画
7. `.litelizard.json` 保存/再読込（`light`/`lizard` 構造）
8. 失敗時UI（通信エラー、部分失敗表示）

## 12. 次回確認したい項目（実装前の最終確認）
1. 辞書形式の確定スキーマ（段落ID発番、バージョン管理）
2. `.md` インポート時の段落分割ルールの例外（引用/コードブロック）
3. 段落ドラッグ&ドロップ後の再解析方針（自動再解析するか否か）

## 13. v0.3 追加決定（2026-02-12）
- 保存形式の結論: 段落並び替えとUI加工を優先し、正本は `JSON` を採用する
- ファイル方針:
  - 正本: `xxx.litelizard.json`
  - 互換/公開用: `xxx.md` のインポート/エクスポートを提供
- 認証方式の結論: `ログイン必須（メールリンク認証）`
- 自動保存: `3秒デバウンス`

## 14. JSONスキーマ案（light/lizard）
```json
{
  "version": 1,
  "title": "string",
  "personaMode": "general-reader",
  "updatedAt": "2026-02-12T00:00:00.000Z",
  "paragraphs": [
    {
      "id": "p_001",
      "order": 1,
      "light": {
        "text": "昨日の夜、コンビニの照明が眩しすぎて逃げるように店を出た。"
      },
      "lizard": {
        "emotion": ["不穏", "緊張"],
        "theme": ["感覚過敏", "社会適応"],
        "deepMeaning": "外界刺激への防衛反応が、孤立感を強めている可能性。",
        "confidence": 0.78,
        "analyzedAt": "2026-02-12T00:00:00.000Z"
      }
    }
  ]
}
```

## 15. 認証方式の採用理由（Q2回答）
- 採用: `ログイン必須（メールリンク認証 + サーバーセッション）`
- 理由1: 一般公開アプリで匿名許可にすると、LLM APIの不正利用とコスト爆発リスクが高い
- 理由2: 招待キー方式は初期導入が速いが、公開運用時にキー流出と再発行運用が重い
- 理由3: メールリンクはパスワード管理が不要で、非エンジニアにも使いやすい
- 理由4: ユーザー単位のレート制限と利用量管理を実装しやすい

## 16. 実装メモ（認証最小構成）
- クライアント: ログイン後に短命アクセストークンを保持
- 中継API: トークン検証後のみ解析APIを実行
- 運用ガード: ユーザーごとのレート制限、日次上限、監査ログ

## 17. v0.4 確定事項（2026-02-12）
- 正式スキーマを確定し、JSON Schemaを作成
  - `/Users/jane/devidea/liteLizard/LiteLizard_schema_v1.json`
- 実装設計書を作成
  - `/Users/jane/devidea/liteLizard/LiteLizard_implementation_design.md`
- 不正利用対策の方針を「後付け可能」ではなく「最小実装を初期導入」に変更
  - `userId` 紐付け
  - usageログ（request/token/cost）
  - 単一ミドルウェア集約
  - 429標準化

## 18. 未解決項目（v0.4時点）
- `.md` importでの引用/箇条書き/コードブロックの詳細分割ルール
- 段落並び替え後の再解析トリガー（手動のみ継続 or 変更段落だけ提案再解析）

## 19. v0.5 確定事項（2026-02-12）
- 正本保存形式は `*.litelizard.json` のみ（完全JSON統一）
- `.md` 保存、`.md` import/export はMVPスコープから削除
- 分析APIリクエストの必須は以下に確定
  - `documentId`
  - `paragraphs[].paragraphId`
  - `paragraphs[].text`
- 部分失敗ポリシーを確定
  - 対象段落のうち1件でも失敗したらAPI全体を失敗として扱う
  - クライアント反映は0件（白紙に戻す）
  - ユーザーに再試行導線を表示する

## 20. APIリクエスト形式（v0.5）
```json
{
  "documentId": "doc_abc123",
  "personaMode": "general-reader",
  "paragraphs": [
    {
      "paragraphId": "p_a1b2c3",
      "order": 3,
      "text": "誰も私を見ていないのに、全員に見られている気がした。"
    }
  ]
}
```

## 21. 現行仕様（v0.5）
- アプリ形態: Electron製デスクトップアプリ（macOS先行）
- ファイル操作: フォルダを開く方式（左ペインにファイルツリー）
- 編集対象: `*.litelizard.json`
- 保存: 自動保存（3秒デバウンス）
- 解析起動: 「解析実行」ボタンによる手動トリガー
- 解析単位: 段落ごと（段落IDベース）
- 編集操作: 段落カードをドラッグ&ドロップで並び替え可能
- AI接続: 自前の中継API経由（ログイン必須）

## 22. 選択待ち（候補あり）
1. `lizard.status` 遷移:
   - 案A: `pending -> complete | failed`、本文変更で `stale`
   - 案B: `idle -> running -> complete | failed`、`stale`は使わない
2. HTTPステータス設計:
   - 案A（詳細）: `200/400/401/403/409/422/429/500/503`
   - 案B（簡易）: `200/400/401/429/500`
3. トークン保存場所:
   - 案A: OSキーチェーン
   - 案B: 暗号化ローカルファイル
   - 案C: メモリのみ
4. 再解析トリガー:
   - 案A: 手動のみ
   - 案B: 手動 + stale段落への提案バッジ

## 23. 廃止扱い（履歴）
- 本ドキュメント上の過去バージョンにある `.md` 保存関連記述は履歴情報としてのみ扱い、現行仕様では無効。

## 24. v0.6 確定事項（2026-02-12）
- `lizard.status` 遷移は案Aを採用
  - `pending -> complete | failed`
  - 本文変更時に `stale`
  - 再解析開始時に `pending`
- HTTPステータスは案Bを採用
  - `200 / 400 / 401 / 429 / 500`
- クライアントトークン保存は案Bを採用
  - 暗号化ローカルファイル
- 再解析トリガーは案Bを採用
  - 手動実行 + `stale` 段落への提案再解析バッジ

## 25. v0.7 追加確定事項（2026-02-12）
1. 同時編集の競合制御: 案A
- `revision` 必須の楽観ロック

2. 解析APIのタイムアウト/再試行: 案A
- サーバー10秒タイムアウト
- クライアント再試行1回

3. 暗号化ローカルファイルの鍵管理: 案A
- OSログイン情報由来鍵で暗号化

4. ファイル破損時リカバリ: 案C
- 自動復旧なし
- 起動時検証 + 手動復旧導線

5. 解析対象段落の送信方式: 案A
- `stale` 段落のみ送信

6. 監査ログ保持: 案A
- 本文保存なし
- メタデータのみ30日保持

7. プロンプトバージョン管理: 案A
- `promptVersion` をリクエスト必須化

8. 配布・更新方式: 案A
- macOS手動配布（zip/dmg）
- 手動更新
